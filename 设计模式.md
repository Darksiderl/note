##设计模式

代码示例：

[模板方法、工场模式、单例模式的综合应用](https://github.com/wswenyue/DesignPattern_Template_Single_Factory "模板方法、工场模式、单例模式的综合应用")
[模板设计模式](https://github.com/wswenyue/DesignPattern_Template "模板设计模式")
[适配器模式](https://github.com/wswenyue/DesignPattern_Adapter "适配器模式")

####单例设计模式
>单例模式构造方法：1 构造函数private 2 创建本类对象（static）  3 提供一个方法给外界用来获取本类对象
>>懒汉式  
>>饿汉式

实现步骤：
    
    单例模式：
    		1)private 类名(){}
    		2) 
    			懒汉式
    				private static 类名 对象名
    			饿汉式（线程安全）
    				private static 类名 对象名 = new 类名（）；
    		3）public static 类名 getInstance（）{
    			懒汉式
    				if（对象名==null）
    					 对象名 = new 类名（）；
    				return 对象名；
    			----------------------------------------
    			饿汉式
    				return 对象名；
    		}


代码实现

    class Demo08
    {
    	/*
    	设计模式：单例
    	解决问题：一个类在内存中只有一个对象
    	1 构造方法私有化
    	2 构造方法私有化后，就一个对象都不能创建了，只能有该类自身提供对象
    		饿汉式：在声明类引用时实例化对象
    		懒汉式：在获取类的方法中先判断该对象是否为空，如果为空就实例化
    	3 提供让外界能够获得该对象的方法
    
    	懒汉式（线程不安全的）
    	饿汉式（线程安全的）
    	*/
    	public static void main(String[] args) 
    	{
    		Single s1 = Single.getInstance();
    		Single s2 = Single.getInstance();
    		System.out.println(s1==s2); //比较的是地址
    
    		Single2 s3 = Single2.getInstance();
    		Single2 s4 = Single2.getInstance();
    		System.out.println(s3==s4);
    	}
    }
    //饿汉式
    class Single
    {
    	
    		//构造方法私有化：不能在本类的外部通过new创建对象
    		private Single(){
    		
    		}
    		//定义一个本类的对象
    		private static Single single = new Single();
    
    		//向外界提供可访问的方法，返回当前类的对象
    		public static Single getInstance(){
    			return single;
    		}
    }
    
    //懒汉式
    class Single2 
    {
    	private Single2(){}
    
    	private static Single2 single ;
    
    	public static Single2 getInstance(){
    		if(single == null)
    			single  = new Single2();
    		return single;
    	}
    
    }

---

#### 简单工厂模式
>简单工厂：工厂生产父类产品，根据传递不同的参数，返回相应的子类产品对象

示例实现：

    import java.util.*;
    class  Factory  //厨房
    {
    	public static IEat cook(int choose){	
    		IEat i = null;
    		switch(choose){
    			case 1:
    				i = new Duck();				
    				break;
    			case 2:
    				i = new Chicken();				
    				break;
    			case 3:
    				i = new Fish();				
    				break;
    			case 4 :
    				i = new Pig();				
    				break;
    			case 5:
    				i = new Beef();
    				break;
    		}
    		return i;
    	}
    
    	//饭店入口
    	public static void main(String[] args) 
    	{
    		Scanner input = new Scanner(System.in);
    		System.out.println("吃啥？1 烤鸭   2 炸鸡  3 水煮鱼  4 烤乳猪 5 烤牛排");
    		int choose = input.nextInt();
    		IEat i = Factory.cook(choose);
    		i.eat();
    		System.out.println("欢迎下次光临！！！");
    
    	}
    }
    interface IEat
    {
    	void eat();  //吃
    }
    class Duck implements IEat
    {
    	public void eat(){
    		System.out.println("吃烤鸭");
    	}
    }
    class Chicken implements IEat
    {
    	public void eat(){
    		System.out.println("吃炸鸡");
    	}
    }
    
    class Fish implements IEat
    {
    	public void eat(){
    		System.out.println("吃水煮鱼");
    	}
    }
    class Pig implements IEat
    {
    	public void eat(){
    		System.out.println("吃烤乳猪");
    	}
    }
    class Beef implements IEat
    {
    	public void eat(){
    		System.out.println("吃牛排");
    	}
    }

#### 模板设计模式

算法示例：

    class Demo12 
    {
    	/*
    	模板模式：
    		定义一个功能时，功能的一部分是确定的，而另一部分不确定。
    		确定的部分需要用到不确定的部分。
    		把不确定的部分暴露出去，让子类实现
    
    		abstract class  类名{
    			//确定部分
    			public void f(){
    				f1();
    			}
    			//不确定部分
    			public abstract void f1();
    		}
    	*/
    	public static void main(String[] args) 
    	{
    		T t = new T();
    		t.getTime();
    	}
    }
    abstract class Test
    {
    	//确定部分
    	public void getTime(){
    		//开始时间:系统时间
    		long start = System.currentTimeMillis();
    		f();
    		//结束时间
    		long end = System.currentTimeMillis();
    
    		System.out.println("花费时间为:"+(end-start)+"ms");
    
    	}
    
    	//不确定部分
    	public abstract void f();
    }
    
    class T extends Test
    {
    		public void f(){
    			for(int i=1;i<50000;i++){
    				//System.out.println("");
    			}
    		}
    }